#! /usr/bin/env python

# main script to run FUCHS

def main():

    # required packages
    import os
    import argparse

    parser = argparse.ArgumentParser(description='Main script of the FUCHS pipeline.'
                                                 'For a detailed help see https://github.com/dieterich-lab/FUCHS '
                                                 'or the included README.rst file.')

    # input
    parser.add_argument('circlefile', metavar='sample_circleIDs.txt',
                        help='Tab-separated file chr:start_end(tab)read1,read2,read3.')
    parser.add_argument('bamfile', metavar='sample.bam',
                        help='BAM file containing chimeric reads, linear reads may be in it but are not required.')
    parser.add_argument('bedfile', metavar='feature.bed', help='bed formatted feature file including exons.')

    # output
    parser.add_argument('outputfolder', metavar='folder',
                        help='Output folder. There will be a sub folder for the sample containing a BAM file '
                             'for each circle.')
    parser.add_argument('sample', metavar='sample_name', help='sample_name to title every thing.')

    # options
    parser.add_argument('-r', dest='reads', default=5, type=int,
                        help='Circle has to have at least <r> reads to be analysed.')

    #TODO: default: no multi map
    parser.add_argument('-q', dest='mapq', default=3, type=int,
                        help='MAPQ cutoff, only reads passing this threshold will be written to circle BAM file.')
    #TODO: add 0 based info
    parser.add_argument('-e', dest='exon_index', default=3, type=int,
                        help='Field indicating the exon number after splitting feature name (for the annotation file).')
    parser.add_argument('-s', dest='split_character', default='_', help='feature name separator.')
    parser.add_argument('-p', dest='ref_platform', default='refseq',
                        help='Specifies the annotation platform which was used (refseq or ensembl)')
    parser.add_argument('-sS', dest='skipped_steps', default='none',
                        help='Comma separated list of steps that should be skipped (e.g. step3,step4,step6)')
    parser.add_argument('-j', dest='star_junction_file', default='none',
                        help='If you mapped with star and are using step1 you need to provide the junction file here')
    parser.add_argument('-m', dest='mates', default='none',
                        help='If you mapped with STAR, have paired end data and, '
                             'are using step1 you need to provide the mate2 junction file here')
    parser.add_argument('-c', dest='circle_ids', default='none',
                        help='If you mapped with star and are using step1 you need to provide a list'
                             ' of circle ids (CircCoordinates from DCC)')
    parser.add_argument('--tmp', dest='tmp_folder', default='/tmp/',
                        help='Folder to store temporary files generated by pybedtools.')

    args = parser.parse_args()

    # parse arguments
    circles = args.circlefile
    bamfile = args.bamfile
    bedfile = args.bedfile
    outfolder = args.outputfolder
    sample = args.sample
    cutoff_reads = args.reads
    cutoff_mapq = args.mapq
    exon_index = args.exon_index
    split_character = args.split_character
    platform = args.ref_platform
    skipped_steps = args.skipped_steps.split(',')
    mates = args.mates
    junctionfile = args.star_junction_file
    circle_ids = args.circle_ids
    tmp_folder = args.tmp_folder

    # test for correct input data
    accepted_platforms = ('refseq', 'ensembl')
    platform = platform.lower()
    if not platform in accepted_platforms:
        print('ERROR please specify an accepted annotation platform. Possible options are: refseq or ensembl')
        quit()

    print "The following analysis steps will be skipped: " + '%s' % ', '.join(map(str, skipped_steps))

    # Step 1: (optional) if DCC was used, extract circle read names from junction file 
    if not 'step1' in skipped_steps:

        circles = "%s.reads.txt" % junctionfile
        import get_readnames_from_DCC as get_readnames
        names = get_readnames.get_readnames_from_DCC(mates, circle_ids, junctionfile)
        names.run()

    # Step2 : extract circle reads from sample bam file
    if not 'step2' in skipped_steps:

        import extract_reads as extract_reads
        er = extract_reads.extract_reads(cutoff_reads, cutoff_mapq, circles, bamfile, outfolder, sample, tmp_folder)
        er.run()

    # Step3 : (optional) get information about possibly rolling circles 
    if not 'step3' in skipped_steps:

        import get_mate_information as mateinformation
        mi = mateinformation.mate_information(platform, split_character, bedfile, outfolder, sample, tmp_folder)
        mi.run()

    # Step4 : (optional) find exon skipping events
    if not 'step4' in skipped_steps:

        import detect_skipped_exons as skipped_exons
        se = skipped_exons.detect_skipped_exons(outfolder, sample, bedfile, tmp_folder, platform)
        se.run()

    # Step5 : (optional) identify different circles within the same host gene
    if not 'step5' in skipped_steps:

        import detect_splicing_variants as splicing_variants
        sv = splicing_variants.detect_splicing_variants(split_character, platform, circles, bedfile,
                                                        outfolder, sample, tmp_folder)
        sv.run()

    # Step6 : (optional) generate coverage profile for each circle
    # (one transcript per gene, best if most fitting transcript)
    if not 'step6' in skipped_steps:
        # os.system('python get_coverage_profile.py -e %s -s %s -p %s %s %s %s --tmp %s' %
        #           (exon_index, split_character, platform, bedfile, outfolder, sample, tmp_folder))

        import get_coverage_profile as coverage_profile
        sv = coverage_profile.get_coverage_profile(exon_index, split_character, platform, bedfile,
                                                   outfolder, sample, tmp_folder)
        sv.run()

    # Step7 : (optional, requires step 5)
    if not 'step7' in skipped_steps:
        if not 'step6' in skipped_steps:
            os.system('Rscript summarized_coverage_profiles.R %s/%s.coverage_profiles' % (outfolder, sample))
        else:
            print('You are trying cluster the coverage profiles without '
                  'generating coverage profiles first, please run step 5')

    # Step8 : (optional, requires step6) pictures for all circles
    if not 'step8' in skipped_steps:
        if not 'step6' in skipped_steps:
            files = os.listdir('%s/%s.coverage_profiles' % (outfolder, sample))
            folders = os.listdir(outfolder)
            if not '%s.coverage_pictures' % (sample) in folders:
                os.mkdir('%s/%s.coverage_pictures' % (outfolder, sample))
            for f in files:
                if f.endswith('.txt'):
                    print('Generating plot for %s' % f)
                    os.system('Rscript make_coverage_picture.R %s/%s.coverage_profiles/%s %s/%s.coverage_pictures/' %
                              (outfolder, sample, f, outfolder, sample))
        else:
            print('You are trying to generate coverage pictures '
                  'without generating coverage profiles, please run step 5')

if __name__ == '__main__':
    main()
